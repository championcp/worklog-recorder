import { Router, Response } from 'express';
import { v4 as uuidv4 } from 'uuid';
import Joi from 'joi';
import { db } from '../database/config';
import { asyncHandler, createError } from '../middleware/errorHandler';
import { AuthRequest, authenticateToken } from '../middleware/auth';
import { ApiResponse, PaginatedResponse, TaskStatus } from '../types';

const router = Router();

// æŠ¥å‘Šç±»å‹æšä¸¾
export enum ReportType {
  DAILY = 'daily',
  WEEKLY = 'weekly',
  MONTHLY = 'monthly',
  QUARTERLY = 'quarterly',
  SEMI_ANNUAL = 'semi_annual',
  ANNUAL = 'annual'
}

// æŠ¥å‘Šæ¥å£
export interface Report {
  id: string;
  title: string;
  type: ReportType;
  content: string;
  startDate: Date;
  endDate: Date;
  statistics: ReportStatistics;
  isAutoGenerated: boolean;
  userId: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface ReportStatistics {
  totalTasks: number;
  completedTasks: number;
  totalHours: number;
  plannedTasks: number;
  unplannedTasks: number;
  completionRate: number;
  categoryStats: Array<{
    categoryId: string;
    categoryName: string;
    taskCount: number;
    hours: number;
  }>;
}

// éªŒè¯æ¨¡å¼
const reportSchema = Joi.object({
  title: Joi.string().min(1).max(200).required(),
  type: Joi.string().valid(...Object.values(ReportType)).required(),
  content: Joi.string().required(),
  startDate: Joi.date().required(),
  endDate: Joi.date().required(),
  isAutoGenerated: Joi.boolean().default(false)
});

// è·å–æŠ¥å‘Šåˆ—è¡¨
router.get('/', authenticateToken, asyncHandler(async (req: AuthRequest, res: Response<ApiResponse<PaginatedResponse<Report>>>) => {
  const userId = req.user!.id;
  const page = parseInt(req.query.page as string) || 1;
  const limit = parseInt(req.query.limit as string) || 20;
  const offset = (page - 1) * limit;
  const type = req.query.type as ReportType;
  const year = req.query.year ? parseInt(req.query.year as string) : undefined;

  // æ„å»ºæŸ¥è¯¢æ¡ä»¶
  let query = db('reports').where('user_id', userId);
  
  if (type) {
    query = query.where('type', type);
  }
  
  if (year) {
    query = query.whereRaw("strftime('%Y', start_date) = ?", [year.toString()]);
  }

  // è·å–æ€»æ•°
  const totalQuery = query.clone();
  const [{ count }] = await totalQuery.count('* as count');
  const total = count as number;

  // è·å–åˆ†é¡µæ•°æ®
  const records = await query
    .orderBy('created_at', 'desc')
    .limit(limit)
    .offset(offset);

  const reports: Report[] = records.map(record => ({
    id: record.id,
    title: record.title,
    type: record.type as ReportType,
    content: record.content,
    startDate: new Date(record.start_date),
    endDate: new Date(record.end_date),
    statistics: JSON.parse(record.statistics || '{}'),
    isAutoGenerated: Boolean(record.is_auto_generated),
    userId: record.user_id,
    createdAt: new Date(record.created_at),
    updatedAt: new Date(record.updated_at)
  }));

  res.json({
    success: true,
    data: {
      data: reports,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit)
    }
  });
}));

// ç”ŸæˆæŠ¥å‘Š
router.post('/generate', authenticateToken, asyncHandler(async (req: AuthRequest, res: Response<ApiResponse<Report>>) => {
  const userId = req.user!.id;
  const { type, startDate, endDate, title } = req.body;

  if (!type || !startDate || !endDate) {
    throw createError('æŠ¥å‘Šç±»å‹ã€å¼€å§‹æ—¥æœŸå’Œç»“æŸæ—¥æœŸæ˜¯å¿…å¡«é¡¹', 400);
  }

  const start = new Date(startDate);
  const end = new Date(endDate);

  // è®¡ç®—ç»Ÿè®¡æ•°æ®
  const statistics = await calculateReportStatistics(userId, start, end);
  
  // ç”ŸæˆæŠ¥å‘Šå†…å®¹
  const content = await generateReportContent(type, statistics, start, end);

  const reportId = uuidv4();
  const now = new Date();

  await db('reports').insert({
    id: reportId,
    title: title || `${getReportTypeLabel(type)} - ${start.toLocaleDateString()}`,
    type,
    content,
    start_date: start,
    end_date: end,
    statistics: JSON.stringify(statistics),
    is_auto_generated: false,
    user_id: userId,
    created_at: now,
    updated_at: now
  });

  const report: Report = {
    id: reportId,
    title: title || `${getReportTypeLabel(type)} - ${start.toLocaleDateString()}`,
    type: type as ReportType,
    content,
    startDate: start,
    endDate: end,
    statistics,
    isAutoGenerated: false,
    userId,
    createdAt: now,
    updatedAt: now
  };

  res.status(201).json({
    success: true,
    data: report,
    message: 'æŠ¥å‘Šç”ŸæˆæˆåŠŸ'
  });
}));

// æ›´æ–°æŠ¥å‘Š
router.put('/:id', authenticateToken, asyncHandler(async (req: AuthRequest, res: Response<ApiResponse<Report>>) => {
  const userId = req.user!.id;
  const reportId = req.params.id;
  const { title, content } = req.body;

  const existingReport = await db('reports')
    .where({ id: reportId, user_id: userId })
    .first();

  if (!existingReport) {
    throw createError('æŠ¥å‘Šä¸å­˜åœ¨', 404);
  }

  const updateData: any = {
    updated_at: new Date()
  };

  if (title !== undefined) updateData.title = title;
  if (content !== undefined) updateData.content = content;

  await db('reports')
    .where({ id: reportId, user_id: userId })
    .update(updateData);

  // è·å–æ›´æ–°åçš„æŠ¥å‘Š
  const updatedRecord = await db('reports')
    .where({ id: reportId, user_id: userId })
    .first();

  const report: Report = {
    id: updatedRecord.id,
    title: updatedRecord.title,
    type: updatedRecord.type as ReportType,
    content: updatedRecord.content,
    startDate: new Date(updatedRecord.start_date),
    endDate: new Date(updatedRecord.end_date),
    statistics: JSON.parse(updatedRecord.statistics || '{}'),
    isAutoGenerated: Boolean(updatedRecord.is_auto_generated),
    userId: updatedRecord.user_id,
    createdAt: new Date(updatedRecord.created_at),
    updatedAt: new Date(updatedRecord.updated_at)
  };

  res.json({
    success: true,
    data: report,
    message: 'æŠ¥å‘Šæ›´æ–°æˆåŠŸ'
  });
}));

// åˆ é™¤æŠ¥å‘Š
router.delete('/:id', authenticateToken, asyncHandler(async (req: AuthRequest, res: Response<ApiResponse>) => {
  const userId = req.user!.id;
  const reportId = req.params.id;

  const existingReport = await db('reports')
    .where({ id: reportId, user_id: userId })
    .first();

  if (!existingReport) {
    throw createError('æŠ¥å‘Šä¸å­˜åœ¨', 404);
  }

  await db('reports').where({ id: reportId, user_id: userId }).del();

  res.json({
    success: true,
    message: 'æŠ¥å‘Šåˆ é™¤æˆåŠŸ'
  });
}));

// è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æŠ¥å‘Šç»Ÿè®¡æ•°æ®
async function calculateReportStatistics(userId: string, startDate: Date, endDate: Date): Promise<ReportStatistics> {
  // è·å–æ—¶é—´èŒƒå›´å†…çš„ä»»åŠ¡
  const tasks = await db('tasks')
    .where('user_id', userId)
    .where('created_at', '>=', startDate)
    .where('created_at', '<=', endDate);

  // è·å–æ—¶é—´è®°å½•
  const timeLogs = await db('time_logs')
    .where('user_id', userId)
    .where('start_time', '>=', startDate)
    .where('start_time', '<=', endDate);

  // è®¡ç®—åŸºæœ¬ç»Ÿè®¡
  const totalTasks = tasks.length;
  const completedTasks = tasks.filter(task => task.status === TaskStatus.COMPLETED).length;
  const totalHours = timeLogs.reduce((sum, log) => sum + (log.duration || 0), 0) / 3600; // è½¬æ¢ä¸ºå°æ—¶

  // è®¡ç®—è®¡åˆ’å†…å¤–ä»»åŠ¡
  const plannedTasks = tasks.filter(task => task.start_date && task.end_date).length;
  const unplannedTasks = totalTasks - plannedTasks;

  // è®¡ç®—å®Œæˆç‡
  const completionRate = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

  // æŒ‰åˆ†ç±»ç»Ÿè®¡
  const categoryStats = await db('tasks')
    .join('categories', 'tasks.category_id', 'categories.id')
    .where('tasks.user_id', userId)
    .where('tasks.created_at', '>=', startDate)
    .where('tasks.created_at', '<=', endDate)
    .groupBy('categories.id', 'categories.name')
    .select(
      'categories.id as categoryId',
      'categories.name as categoryName',
      db.raw('COUNT(tasks.id) as taskCount'),
      db.raw('COALESCE(SUM(tasks.actual_hours), 0) as hours')
    );

  return {
    totalTasks,
    completedTasks,
    totalHours,
    plannedTasks,
    unplannedTasks,
    completionRate,
    categoryStats: categoryStats.map(stat => ({
      categoryId: stat.categoryId,
      categoryName: stat.categoryName,
      taskCount: parseInt(stat.taskCount),
      hours: parseFloat(stat.hours)
    }))
  };
}

// è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆæŠ¥å‘Šå†…å®¹
async function generateReportContent(type: ReportType, statistics: ReportStatistics, startDate: Date, endDate: Date): Promise<string> {
  const typeLabel = getReportTypeLabel(type);
  const dateRange = `${startDate.toLocaleDateString()} - ${endDate.toLocaleDateString()}`;

  let content = `# ${typeLabel}æŠ¥å‘Š\n\n`;
  content += `**æŠ¥å‘ŠæœŸé—´ï¼š** ${dateRange}\n\n`;
  content += `## ğŸ“Š æ€»ä½“ç»Ÿè®¡\n\n`;
  content += `- **æ€»ä»»åŠ¡æ•°ï¼š** ${statistics.totalTasks}\n`;
  content += `- **å·²å®Œæˆä»»åŠ¡ï¼š** ${statistics.completedTasks}\n`;
  content += `- **å®Œæˆç‡ï¼š** ${statistics.completionRate.toFixed(1)}%\n`;
  content += `- **æ€»å·¥ä½œæ—¶é•¿ï¼š** ${statistics.totalHours.toFixed(1)} å°æ—¶\n`;
  content += `- **è®¡åˆ’å†…ä»»åŠ¡ï¼š** ${statistics.plannedTasks}\n`;
  content += `- **è®¡åˆ’å¤–ä»»åŠ¡ï¼š** ${statistics.unplannedTasks}\n\n`;

  if (statistics.categoryStats.length > 0) {
    content += `## ğŸ“‹ åˆ†ç±»ç»Ÿè®¡\n\n`;
    statistics.categoryStats.forEach(stat => {
      content += `### ${stat.categoryName}\n`;
      content += `- ä»»åŠ¡æ•°é‡ï¼š${stat.taskCount}\n`;
      content += `- å·¥ä½œæ—¶é•¿ï¼š${stat.hours.toFixed(1)} å°æ—¶\n\n`;
    });
  }

  content += `## ğŸ“ˆ åˆ†æä¸å»ºè®®\n\n`;
  
  if (statistics.completionRate >= 80) {
    content += `âœ… å®Œæˆç‡è¡¨ç°ä¼˜ç§€ï¼ˆ${statistics.completionRate.toFixed(1)}%ï¼‰ï¼Œç»§ç»­ä¿æŒï¼\n\n`;
  } else if (statistics.completionRate >= 60) {
    content += `âš ï¸ å®Œæˆç‡è‰¯å¥½ï¼ˆ${statistics.completionRate.toFixed(1)}%ï¼‰ï¼Œè¿˜æœ‰æå‡ç©ºé—´ã€‚\n\n`;
  } else {
    content += `âŒ å®Œæˆç‡åä½ï¼ˆ${statistics.completionRate.toFixed(1)}%ï¼‰ï¼Œå»ºè®®ä¼˜åŒ–æ—¶é—´ç®¡ç†å’Œä»»åŠ¡è§„åˆ’ã€‚\n\n`;
  }

  if (statistics.unplannedTasks > statistics.plannedTasks) {
    content += `ğŸ“ è®¡åˆ’å¤–ä»»åŠ¡è¾ƒå¤šï¼Œå»ºè®®åŠ å¼ºä»»åŠ¡è§„åˆ’å’Œæ—¶é—´ç®¡ç†ã€‚\n\n`;
  }

  return content;
}

// è¾…åŠ©å‡½æ•°ï¼šè·å–æŠ¥å‘Šç±»å‹æ ‡ç­¾
function getReportTypeLabel(type: ReportType): string {
  const labels = {
    [ReportType.DAILY]: 'æ—¥',
    [ReportType.WEEKLY]: 'å‘¨',
    [ReportType.MONTHLY]: 'æœˆ',
    [ReportType.QUARTERLY]: 'å­£åº¦',
    [ReportType.SEMI_ANNUAL]: 'åŠå¹´åº¦',
    [ReportType.ANNUAL]: 'å¹´åº¦'
  };
  return labels[type] || 'æœªçŸ¥';
}

export { router as reportRoutes };